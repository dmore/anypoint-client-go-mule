/*
 * Exchange Assets
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package exchange_asset

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MiscApiService MiscApi service
type MiscApiService service

type MiscApiApiCreateanewassetRequest struct {
	ctx _context.Context
	ApiService *MiscApiService
	organizationId *string
	assetId *string
	version *string
	name *string
	classifier *string
	apiVersion *string
	main *string
	groupId *string
	asset *string
	authorization *string
}

func (r MiscApiApiCreateanewassetRequest) OrganizationId(organizationId string) MiscApiApiCreateanewassetRequest {
	r.organizationId = &organizationId
	return r
}
func (r MiscApiApiCreateanewassetRequest) AssetId(assetId string) MiscApiApiCreateanewassetRequest {
	r.assetId = &assetId
	return r
}
func (r MiscApiApiCreateanewassetRequest) Version(version string) MiscApiApiCreateanewassetRequest {
	r.version = &version
	return r
}
func (r MiscApiApiCreateanewassetRequest) Name(name string) MiscApiApiCreateanewassetRequest {
	r.name = &name
	return r
}
func (r MiscApiApiCreateanewassetRequest) Classifier(classifier string) MiscApiApiCreateanewassetRequest {
	r.classifier = &classifier
	return r
}
func (r MiscApiApiCreateanewassetRequest) ApiVersion(apiVersion string) MiscApiApiCreateanewassetRequest {
	r.apiVersion = &apiVersion
	return r
}
func (r MiscApiApiCreateanewassetRequest) Main(main string) MiscApiApiCreateanewassetRequest {
	r.main = &main
	return r
}
func (r MiscApiApiCreateanewassetRequest) GroupId(groupId string) MiscApiApiCreateanewassetRequest {
	r.groupId = &groupId
	return r
}
func (r MiscApiApiCreateanewassetRequest) Asset(asset string) MiscApiApiCreateanewassetRequest {
	r.asset = &asset
	return r
}
func (r MiscApiApiCreateanewassetRequest) Authorization(authorization string) MiscApiApiCreateanewassetRequest {
	r.authorization = &authorization
	return r
}

func (r MiscApiApiCreateanewassetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateanewassetExecute(r)
}

/*
 * Createanewasset Createanewasset
 * Create a new asset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return MiscApiApiCreateanewassetRequest
 */
func (a *MiscApiService) Createanewasset(ctx _context.Context) MiscApiApiCreateanewassetRequest {
	return MiscApiApiCreateanewassetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *MiscApiService) CreateanewassetExecute(r MiscApiApiCreateanewassetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscApiService.Createanewasset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.organizationId == nil {
		return nil, reportError("organizationId is required and must be specified")
	}
	if r.assetId == nil {
		return nil, reportError("assetId is required and must be specified")
	}
	if r.version == nil {
		return nil, reportError("version is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}
	if r.classifier == nil {
		return nil, reportError("classifier is required and must be specified")
	}
	if r.apiVersion == nil {
		return nil, reportError("apiVersion is required and must be specified")
	}
	if r.main == nil {
		return nil, reportError("main is required and must be specified")
	}
	if r.groupId == nil {
		return nil, reportError("groupId is required and must be specified")
	}
	if r.asset == nil {
		return nil, reportError("asset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	localVarFormParams.Add("organizationId", parameterToString(*r.organizationId, ""))
	localVarFormParams.Add("assetId", parameterToString(*r.assetId, ""))
	localVarFormParams.Add("version", parameterToString(*r.version, ""))
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	localVarFormParams.Add("classifier", parameterToString(*r.classifier, ""))
	localVarFormParams.Add("apiVersion", parameterToString(*r.apiVersion, ""))
	localVarFormParams.Add("main", parameterToString(*r.main, ""))
	localVarFormParams.Add("groupId", parameterToString(*r.groupId, ""))
	localVarFormParams.Add("asset", parameterToString(*r.asset, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MiscApiApiDeleteanassetRequest struct {
	ctx _context.Context
	ApiService *MiscApiService
	xDeleteType *string
	cloudhubOrg string
	cloudhubExAsset string
	cloudhubExVersion string
	authorization *string
}

func (r MiscApiApiDeleteanassetRequest) XDeleteType(xDeleteType string) MiscApiApiDeleteanassetRequest {
	r.xDeleteType = &xDeleteType
	return r
}
func (r MiscApiApiDeleteanassetRequest) Authorization(authorization string) MiscApiApiDeleteanassetRequest {
	r.authorization = &authorization
	return r
}

func (r MiscApiApiDeleteanassetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteanassetExecute(r)
}

/*
 * Deleteanasset Deleteanasset
 * Delete an asset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cloudhubOrg
 * @param cloudhubExAsset
 * @param cloudhubExVersion
 * @return MiscApiApiDeleteanassetRequest
 */
func (a *MiscApiService) Deleteanasset(ctx _context.Context, cloudhubOrg string, cloudhubExAsset string, cloudhubExVersion string) MiscApiApiDeleteanassetRequest {
	return MiscApiApiDeleteanassetRequest{
		ApiService: a,
		ctx: ctx,
		cloudhubOrg: cloudhubOrg,
		cloudhubExAsset: cloudhubExAsset,
		cloudhubExVersion: cloudhubExVersion,
	}
}

/*
 * Execute executes the request
 */
func (a *MiscApiService) DeleteanassetExecute(r MiscApiApiDeleteanassetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscApiService.Deleteanasset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assets/{cloudhub-org}/{cloudhub-ex-asset}/{cloudhub-ex-version}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-org"+"}", _neturl.PathEscape(parameterToString(r.cloudhubOrg, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-ex-asset"+"}", _neturl.PathEscape(parameterToString(r.cloudhubExAsset, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-ex-version"+"}", _neturl.PathEscape(parameterToString(r.cloudhubExVersion, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xDeleteType == nil {
		return nil, reportError("xDeleteType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	localVarHeaderParams["x-delete-type"] = parameterToString(*r.xDeleteType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MiscApiApiGetAssetRequest struct {
	ctx _context.Context
	ApiService *MiscApiService
	search *string
	types *string
	domain *string
	masterOrganizationId *string
	offset *int32
	limit *int32
	sharedWithMe *string
	includeSnapshots *bool
	authorization *string
}

func (r MiscApiApiGetAssetRequest) Search(search string) MiscApiApiGetAssetRequest {
	r.search = &search
	return r
}
func (r MiscApiApiGetAssetRequest) Types(types string) MiscApiApiGetAssetRequest {
	r.types = &types
	return r
}
func (r MiscApiApiGetAssetRequest) Domain(domain string) MiscApiApiGetAssetRequest {
	r.domain = &domain
	return r
}
func (r MiscApiApiGetAssetRequest) MasterOrganizationId(masterOrganizationId string) MiscApiApiGetAssetRequest {
	r.masterOrganizationId = &masterOrganizationId
	return r
}
func (r MiscApiApiGetAssetRequest) Offset(offset int32) MiscApiApiGetAssetRequest {
	r.offset = &offset
	return r
}
func (r MiscApiApiGetAssetRequest) Limit(limit int32) MiscApiApiGetAssetRequest {
	r.limit = &limit
	return r
}
func (r MiscApiApiGetAssetRequest) SharedWithMe(sharedWithMe string) MiscApiApiGetAssetRequest {
	r.sharedWithMe = &sharedWithMe
	return r
}
func (r MiscApiApiGetAssetRequest) IncludeSnapshots(includeSnapshots bool) MiscApiApiGetAssetRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}
func (r MiscApiApiGetAssetRequest) Authorization(authorization string) MiscApiApiGetAssetRequest {
	r.authorization = &authorization
	return r
}

func (r MiscApiApiGetAssetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAssetExecute(r)
}

/*
 * GetAsset GetAsset
 * Get Asset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return MiscApiApiGetAssetRequest
 */
func (a *MiscApiService) GetAsset(ctx _context.Context) MiscApiApiGetAssetRequest {
	return MiscApiApiGetAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *MiscApiService) GetAssetExecute(r MiscApiApiGetAssetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscApiService.GetAsset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.search == nil {
		return nil, reportError("search is required and must be specified")
	}
	if r.types == nil {
		return nil, reportError("types is required and must be specified")
	}
	if r.domain == nil {
		return nil, reportError("domain is required and must be specified")
	}
	if r.masterOrganizationId == nil {
		return nil, reportError("masterOrganizationId is required and must be specified")
	}
	if r.offset == nil {
		return nil, reportError("offset is required and must be specified")
	}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}
	if r.sharedWithMe == nil {
		return nil, reportError("sharedWithMe is required and must be specified")
	}
	if r.includeSnapshots == nil {
		return nil, reportError("includeSnapshots is required and must be specified")
	}

	localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	localVarQueryParams.Add("domain", parameterToString(*r.domain, ""))
	localVarQueryParams.Add("masterOrganizationId", parameterToString(*r.masterOrganizationId, ""))
	localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	localVarQueryParams.Add("sharedWithMe", parameterToString(*r.sharedWithMe, ""))
	localVarQueryParams.Add("includeSnapshots", parameterToString(*r.includeSnapshots, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MiscApiApiGetonespecificAssetRequest struct {
	ctx _context.Context
	ApiService *MiscApiService
	cloudhubOrg string
	cloudhubExAsset string
	authorization *string
}

func (r MiscApiApiGetonespecificAssetRequest) Authorization(authorization string) MiscApiApiGetonespecificAssetRequest {
	r.authorization = &authorization
	return r
}

func (r MiscApiApiGetonespecificAssetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetonespecificAssetExecute(r)
}

/*
 * GetonespecificAsset GetonespecificAsset
 * Get one specific Asset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cloudhubOrg
 * @param cloudhubExAsset
 * @return MiscApiApiGetonespecificAssetRequest
 */
func (a *MiscApiService) GetonespecificAsset(ctx _context.Context, cloudhubOrg string, cloudhubExAsset string) MiscApiApiGetonespecificAssetRequest {
	return MiscApiApiGetonespecificAssetRequest{
		ApiService: a,
		ctx: ctx,
		cloudhubOrg: cloudhubOrg,
		cloudhubExAsset: cloudhubExAsset,
	}
}

/*
 * Execute executes the request
 */
func (a *MiscApiService) GetonespecificAssetExecute(r MiscApiApiGetonespecificAssetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscApiService.GetonespecificAsset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assets/{cloudhub-org}/{cloudhub-ex-asset}/asset"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-org"+"}", _neturl.PathEscape(parameterToString(r.cloudhubOrg, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-ex-asset"+"}", _neturl.PathEscape(parameterToString(r.cloudhubExAsset, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MiscApiApiModifyanassetRequest struct {
	ctx _context.Context
	ApiService *MiscApiService
	cloudhubOrg string
	cloudhubExAsset string
	modifyanassetRequest *ModifyanassetRequest
	authorization *string
}

func (r MiscApiApiModifyanassetRequest) ModifyanassetRequest(modifyanassetRequest ModifyanassetRequest) MiscApiApiModifyanassetRequest {
	r.modifyanassetRequest = &modifyanassetRequest
	return r
}
func (r MiscApiApiModifyanassetRequest) Authorization(authorization string) MiscApiApiModifyanassetRequest {
	r.authorization = &authorization
	return r
}

func (r MiscApiApiModifyanassetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ModifyanassetExecute(r)
}

/*
 * Modifyanasset Modifyanasset
 * Modify an asset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cloudhubOrg
 * @param cloudhubExAsset
 * @return MiscApiApiModifyanassetRequest
 */
func (a *MiscApiService) Modifyanasset(ctx _context.Context, cloudhubOrg string, cloudhubExAsset string) MiscApiApiModifyanassetRequest {
	return MiscApiApiModifyanassetRequest{
		ApiService: a,
		ctx: ctx,
		cloudhubOrg: cloudhubOrg,
		cloudhubExAsset: cloudhubExAsset,
	}
}

/*
 * Execute executes the request
 */
func (a *MiscApiService) ModifyanassetExecute(r MiscApiApiModifyanassetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscApiService.Modifyanasset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assets/{cloudhub-org}/{cloudhub-ex-asset}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-org"+"}", _neturl.PathEscape(parameterToString(r.cloudhubOrg, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudhub-ex-asset"+"}", _neturl.PathEscape(parameterToString(r.cloudhubExAsset, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.modifyanassetRequest == nil {
		return nil, reportError("modifyanassetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	// body params
	localVarPostBody = r.modifyanassetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
